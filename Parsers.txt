

parse_FUNC_FULL_DEFS()
{
Token  *t= next_token();
  switch (t->kind)
  {
  case TOKEN_KEYWORD_INT:
  {
  Token  *t1= next_token();
  if( t1 -> kind == TOKEN_ID ) 
    {
	 t1 = back_token();
	 t = back_token();
	 parse_FUNC_WITH_BODY();
	 parse_FUNC_FULL_DEFS'();
	 break; 
	}
	t1 = back_token();
	t = back_token();
	break;
  }
  case TOKEN_KEYWORD_FLOAT : 
   {
  Token  *t1= next_token();
  if( t1 -> kind == TOKEN_ID ) 
    {
	 t1 = back_token();
	 t = back_token();
	parse_FUNC_WITH_BODY();
	 parse_FUNC_FULL_DEFS'();
	 break; 
	}
	t1 = back_token();
	t = back_token();
	break;
  }
  case TOKEN_KEYWORD_VOID: 
   {
  Token  *t1= next_token();
  if( t1 -> kind == TOKEN_ID ) 
    {
	 t1 = back_token();
	 t = back_token();
   	parse_FUNC_WITH_BODY();
	 parse_FUNC_FULL_DEFS'();
	 break; 
	}
	t1 = back_token();
	t = back_token();
	break;
  }	
  default: error;
  }
}
}


////////////////////
void parser_GLOBAL_VARS()
{
  
    parser_VAR_DEC();
    parser_GLOBAL_VARS'();
	
}
///////////////////////////////// 
parse_GLOBAL_VARS'()
{
Token  *t= next_token();
  switch (t->kind)
  {
  case TOKEN_KEYWORD_INT:
  {
  Token  *t1= next_token();
  if( t1 -> kind == TOKEN_ID ) 
    {
	 t1 = back_token();
	 t = back_token();
	 parse_VAR_DEC();
     parse_GLOBAL_VARS'();
	 break; 
	}
	t1 = back_token();
	t = back_token();
	break;
  }
  case TOKEN_KEYWORD_FLOAT : 
   {
  Token  *t1= next_token();
  if( t1 -> kind == TOKEN_ID ) 
    {
	 t1 = back_token();
	 t = back_token();
	 parse_VAR_DEC();
     parse_GLOBAL_VARS'();
	 break; 
	}
	t1 = back_token();
	t = back_token();
	break;
  }
  case TOKEN_KEYWORD_VOID: t = back_token(); break;
  default: error;
  }
}

parse_FUNC_WITH_BODY()
{
parse_FUNC_PROTOTYPE();
parse_COMP_STMT();
}

parse_FUNC_FULL_DEFS()
{
parse_FUNC_WITH_BODY();
parse_FUNC_FULL_DEFS'();
}


parse_STMT' ()
{
 Token  *t= next_token();
  switch (t->kind)
  {
  case TOKEN_LEFT_PARENTHESIS: parse_ARGS(); match(TOKEN_RIEHT_PARENTHESIS); break;
  case TOKEN_LEFT_BRACKET: t= back_token(); parse_VAR'();  break; 
  case TOKEN_OP_EQUAL: parse_EXPR(); break;
  default: error;
  }
}

parse_FACTOR'()
{
  Token  *t= next_token();
  switch (t->kind)
  {
    case TOKEN_LEFT_PARENTHESIS : parse_ARGS(); match(TOKEN_RIEHT_PARENTHESIS); break;
     case TOKEN_LEFT_BRACKET: t= back_token(); parse_VAR'(); break;
     
	 case TOKEN_LESS_THAN :  t = back_token();  break; 
     case	 TOKEN_GREATER_THAN : t = back_token(); break; 
	 caseTOKEN_GREATER_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_LESS_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_IS_NOT_EQUAL_TO:   t = back_token();  break; 
     case	TOKEN_DOUBLE_EQUAL:  t = back_token();  break; 
	 case TOKEN_MULTIPLICATION:  t = back_token();  break;
	 case  TOKEN_PLUS:  t = back_token();  break;
	 case TOKEN_COMMA: t = back_token();  break;
	 case TOKEN_RIEHT_PARENTHESIS: t = back_token();  break;
	 case TOKEN_SEMICOLON:t = back_token();  break;
	 case TOKEN_RIGHT_BRACKET:t = back_token();  break;
	 case TOKEN_RIGHT_CURLY_BRACES: t = back_token();  break;
     default: error; 
	 
	 }
}

parse_TERM'()
{

Token  *t= next_token();
  switch (t->kind)
  {
    case TOKEN_MULTIPLICATION : parse_FACTOR(); parse_TERM'(); break;
	
    case TOKEN_LESS_THAN :  t = back_token();  break; 
     case	 TOKEN_GREATER_THAN : t = back_token(); break; 
	 caseTOKEN_GREATER_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_LESS_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_IS_NOT_EQUAL_TO:   t = back_token();  break; 
     case	TOKEN_DOUBLE_EQUAL:  t = back_token();  break; 

	 case  TOKEN_PLUS:  t = back_token();  break;
	 case TOKEN_COMMA: t = back_token();  break;
	 case TOKEN_RIEHT_PARENTHESIS: t = back_token();  break;
	 case TOKEN_SEMICOLON:t = back_token();  break;
	 case TOKEN_RIGHT_BRACKET:t = back_token();  break;
	 case TOKEN_RIGHT_CURLY_BRACES: t = back_token();  break;
     default: error; 
  }
}

parse_EXPR'()
{
Token  *t= next_token();
  switch (t->kind)
  {
    case TOKEN_PLUS : parse_TERM(); parse_EXPR'(); break;
  
     case TOKEN_GREATER_THAN : t = back_token(); break; 
	 caseTOKEN_GREATER_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_LESS_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_IS_NOT_EQUAL_TO:   t = back_token();  break; 
     case	TOKEN_DOUBLE_EQUAL:  t = back_token();  break; 
	
	 case TOKEN_COMMA: t = back_token();  break;
	 case TOKEN_RIEHT_PARENTHESIS: t = back_token();  break;
	 case TOKEN_SEMICOLON:t = back_token();  break;
	 case TOKEN_RIGHT_BRACKET:t = back_token();  break;
	 case TOKEN_RIGHT_CURLY_BRACES: t = back_token();  break;
	
     default: error; 
  
  }

}


parse_EXPR_LIST'()
{
Token  *t= next_token();
  switch (t->kind)
  {
  case TOKEN_RIGHT_BRACKET : t= back_token(); break;
  case TOKEN_COMMA: parse_EXPR(); parse_EXPR_LIST'(); break;
  default: error; 
  }
  
}




parse_VAR'()
{
Token  *t= next_token();
  switch (t->kind)
  {
     case TOKEN_LESS_THAN :  t = back_token();  break; 
     case	 TOKEN_GREATER_THAN : t = back_token(); break; 
	 caseTOKEN_GREATER_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_LESS_THAN_OR_EQUAL_TO: t = back_token();  break; 
     case	TOKEN_IS_NOT_EQUAL_TO:   t = back_token();  break; 
     case	TOKEN_DOUBLE_EQUAL:  t = back_token();  break; 
	 case TOKEN_MULTIPLICATION:  t = back_token();  break;
	 case  TOKEN_PLUS:  t = back_token();  break;
	 case TOKEN_COMMA: t = back_token();  break;
	 case TOKEN_RIEHT_PARENTHESIS: t = back_token();  break;
	 case TOKEN_OP_EQUAL:t = back_token();  break;
	 case TOKEN_SEMICOLON:t = back_token();  break;
	 case TOKEN_RIGHT_BRACKET:t = back_token();  break;
	 case TOKEN_RIGHT_CURLY_BRACES: t = back_token();  break;
	 case TOKEN_LEFT_BRACKET: parse_EXPR_LIST(); match(TOKEN_RIGHT_BRACKET); break;
     default: error;
  }
}

parse_RETURN_STMT'()
{
Token  *t= next_token();
 switch (t->kind)
 {
 case TOKEN_SEMICOLON: t= back_token();break;
 case TOKEN_RIGHT_CURLY_BRACES :  t= back_token();break;
 case TOKEN_INTEGER_NUMBER :  
			{		
            t= back_token();	
            parse_EXPR();
			break;
			}
case TOKEN_FLOAT_NUMBER: 
			{
			t= back_token();	
            parse_EXPR();
			break;
			}
case TOKEN_ID: 
			{
			t= back_token();	
            parse_EXPR();
			break;
			}
case TOKEN_LEFT_PARENTHESIS:
		{
			t= back_token();	
            parse_EXPR();
			break;
			}	
 default: error;
 }
}



parse_ARG_LIST'()
{
Token  *t= next_token();
 switch (t->kind)
    {
	case TOKEN_RIEHT_PARENTHESIS: t= back_token(); break;
	case TOKEN_COMMA: parse_ EXPR(); parse_ARG_LIST'(); break;
	default: error;
	}

}




parse_FUNC_FULL_DEFS' ()
{
Token  *t= next_token();
 switch (t->kind)
    {
	  case TOKEN_EOF :  t= back_token(); break;
	  case TOKEN_KEYWORD_VOID: t= back_token(); parse_FUNC_WITH_BODY(); parse_FUNC_FULL_DEFS'(); break();
	  case TOKEN_KEYWORD_INT: t= back_token(); parse_FUNC_WITH_BODY(); parse_FUNC_FULL_DEFS'(); break();
	  case TOKEN_KEYWORD_FLOAT: t= back_token(); parse_FUNC_WITH_BODY(); parse_FUNC_FULL_DEFS'(); break();
	  default: error;
	}

}

parse_FACTOR()
{
Token  *t= next_token();
 switch (t->kind)
    {
	  case TOKEN_ID : parse_FACTOR'(); break;
	  case TOKEN_LEFT_PARENTHESIS: parse_EXPR(); match(TOKEN_RIEHT_PARENTHESIS); break;
	  case TOKEN_INTEGER_NUMBER :break;
	  case  TOKEN_FLOAT_NUMBER : break;
	  default: error;
	}
}

parse_TERM()
{
parse_FACTOR();
parse_TERM'();
}

parse_EXPR()
{
parse_TERM();
parse_EXPR'();
}

parse_CONDITION()
{
parse_EXPR();
Token  *t= next_token();
  switch (t->kind)
  {
     case TOKEN_LESS_THAN :  parse_EXPR(); break; 
     case	 TOKEN_GREATER_THAN : parse_EXPR(); break; 
	 caseTOKEN_GREATER_THAN_OR_EQUAL_TO: parse_EXPR(); break; 
     case	TOKEN_LESS_THAN_OR_EQUAL_TO:  parse_EXPR(); break; 
     case	TOKEN_IS_NOT_EQUAL_TO:   parse_EXPR(); break; 
     case	TOKEN_DOUBLE_EQUAL:  parse_EXPR(); break; 
     default: error;
  }

}

parse_EXPR_LIST()
{
parse_EXPR();
parse_EXPR_LIST'();
}

parse_VAR()
{
Token  *t= next_token();
 if(t->kind != 	TOKEN_ID)
     error;
parse_VAR'();
}

void parser ()
{
parser_PROG();
match(TOKEN_EOF);
}

parse_RETURN_STMT()
{
Token  *t= next_token();
 if(t->kind != TOKEN_KEYWORD_RETURN)
     error;
 parse_RETURN_STMT'(); 
}

parse_ARG_LIST ()
{
parse_EXPR();
parse_ARG_LIST'();
}

parse_ARGS()
{
Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_INTEGER_NUMBER :  
			{		
            t= back_token();	
            parse_ARG_LIST();
			break;
			}
			case TOKEN_FLOAT_NUMBER: 
			{
			 t= back_token();	
            parse_ARG_LIST();
			break;
			}
			case TOKEN_ID: 
			{
			 t= back_token();	
            parse_ARG_LIST();
			break;
			}
			case TOKEN_LEFT_PARENTHESIS: 
			{
			t= back_token();	
            parse_ARG_LIST();
			break;
			}
			case TOKEN_RIEHT_PARENTHESIS: 
			{
			t= back_token();	
			break;
			}
			default: error;
			}
}


parse_CALL()
{
Token  *t= next_token();
if (t->kind != 	TOKEN_KEYWORD_IF)
    error;

match(TOKEN_LEFT_PARENTHESIS);	
parse_ARGS();
match(TOKEN_RIEHT_PARENTHESIS);
}

parse_IF_STMT()
{
Token  *t= next_token();
if (t->kind != 	TOKEN_KEYWORD_IF)
    error;
match(TOKEN_LEFT_PARENTHESIS);	
parse_CONDITION();
match(TOKEN_RIEHT_PARENTHESIS);
parse_STMT();	
}


parse_STMT_LIST'()
{
Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_SEMICOLON: parse_STMT(); parse_STMT_LIST'(); break;
			case TOKEN_RIGHT_CURLY_BRACES: t= back_token(); break;
			default: error; 
			}
}

parse_STMT_LIST()
{
parse_STMT();
parse_STMT_LIST'();
}

  
parse_STMT()
{

Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_ID: parse_STMT'(); break;
			case  TOKEN_KEYWORD_IF:    t= back_token(); parse_ COMP_STMT(); break;
			case TOKEN_KEYWORD_RETURN:  t= back_token(); parse_RETURN_STMT (); break;
			case TOKEN_LEFT_CURLY_BRACES: t= back_token(); parse_ COMP_STMT(); break;
			default: error
			}

}

parse_VAR_DEC_LIST'()
{

Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_KEYWORD_FLOAT:  
			{		
            t= back_token();	
            parse_VAR_DEC();				
			parse_VAR_DEC_LIST'();
			break;
			}
			case TOKEN_KEYWORD_INT: 
			{
			t= back_token();	
            parse_VAR_DEC();	
			parse_VAR_DEC_LIST'();
			break;
			}
			case TOKEN_LEFT_CURLY_BRACES : t= back_token(); break;
			case TOKEN_ID: t= back_token(); break;
			case TOKEN_KEYWORD_IF: t= back_token(); break;
			case TOKEN_KEYWORD_RETURN: t= back_token(); break;
			default: error;
			}
}


parse_VAR_DEC_LIST()
{

Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_KEYWORD_FLOAT:  
			{		
            t= back_token();	
            parse_VAR_DEC();				
			parse_VAR_DEC_LIST'();
			break;
			}
			case TOKEN_KEYWORD_INT: 
			{
			t= back_token();	
            parse_VAR_DEC();	
			parse_VAR_DEC_LIST'();
			break;
			}
			case TOKEN_LEFT_CURLY_BRACES : t= back_token(); break;
			case TOKEN_ID: t= back_token(); break;
			case TOKEN_KEYWORD_IF: t= back_token(); break;
			case TOKEN_KEYWORD_RETURN: t= back_token(); break;
			default: error;
			}
}


parse_COMP_STMT ()
{
match(TOKEN_LEFT_CURLY_BRACES);
parse_VAR_DEC_LIST();
parse_STMT_LIST();
match(TOKEN_RIGHT_CURLY_BRACES);
}

parse_PARAM_LIST'()
{
Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_COMMA:  
			{			
			parse_PARAM();
			parse_PARAM_LIST'();
			break;
			}
			case TOKEN_RIEHT_PARENTHESIS: t= back_token(); break;
			default: error;
			}
}


parse_PARAM_LIST()
{
parse_ PARAM();
parse_PARAM_LIST' ();
}


parse_PARAM()
{

parse_TYPE();
match(TOKEN_ID);
parse_ PARAM'();
}

parse_ PARAM'()
{
Token  *t= next_token();
			switch (t->kind)
			{
            case TOKEN_COMMA:     t= back_token(); break;
			case TOKEN_RIEHT_PARENTHESIS:    t= back_token(); break;
			case TOKEN_LEFT_BRACKET: parse_DIM_SIZES(); match(TOKEN_RIGHT_BRACKET); break;
			default: error;
            }
}


parse_PARAMS()
{
			Token  *t= next_token();
			switch (t->kind)
			{
            case TOKEN_KEYWORD_INT: t= back_token(); parse_PARAM_LIST (); break;
			case TOKEN_KEYWORD_FLOAT:t= back_token(); parse_PARAM_LIST (); break;
			case TOKEN_RIEHT_PARENTHESIS: t= back_token();break;
			default: error;
            }
}

parse_RETURNED_TYPE()
{
 Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_KEYWORD_INT: t= back_token(); parse_TYPE(); break;
			case TOKEN_KEYWORD_FLOAT:t= back_token(); parse_TYPE(); break;
			case TOKEN_KEYWORD_VOID: break;
			default: error;
			}
}


parse_FUNC_PROTOTYPE()
{
parse_RETURNED_TYPE ();
match(TOKEN_ID);
match(TOKEN_LEFT_PARENTHESIS);
parse_PARAMS();
match(TOKEN_RIEHT_PARENTHESIS);
}


parse_DIM_SIZES'()
{
 Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_COMMA:  
			{			
			match(TOKEN_INTEGER_NUMBER);
			parse_DIM_SIZES'()
			break;
			}
			case TOKEN_RIGHT_BRACKET: t= back_token(); break;
			default: error;
			}
}

parse_DIM_SIZES()
{

 Token  *t= next_token();
            
	if(t->kind != TOKEN_INTEGER_NUMBER)
	    error;	
	parse_DIM_SIZES' ();
	
}

parse_TYPE()
{
  Token  *t= next_token();
  switch (t->kind)
			{
			case TOKEN_KEYWORD_INT: break;
			case KEYWORD_FLOAT: break;
			default: error;
			}

}

parser_VAR_DEC();
	{
	parse_TYPE();
	t= next_token();
	if(t->kind != TOKEN_ID)
	   error;
	parse_ VAR_DEC' ();
	}


parse_ VAR_DEC' ()
{
  Token *t= next_token();
  switch (t->kind)
			{
			case TOKEN_SEMICOLON: break;
			case TOKEN_LEFT_BRACKET:
			{
			parser_DIM_SIZES(); 
			match(TOKEN_RIGHT_BRACKET); 
			match(TOKEN_SEMICOLON);
			break;
			}
		    default: error
			}

}


